% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pp-multi_2.R
\name{ppMulti}
\alias{ppMulti}
\alias{simm.fda}
\title{Simultaneous inference for Misaligned Multivarariate functional data}
\usage{
ppMulti(y, t, basis_fct, warp_fct, amp_cov = NULL, warp_cov = NULL,
  iter = c(5, 5), w0 = NULL, amp_cov_par, use.nlm = c(FALSE, FALSE),
  use.laplace = FALSE, paramMax = rep(TRUE, length(amp_cov_par)),
  parallel = c(), warp_opt = TRUE, like_optim_control = list(),
  pr = FALSE, design = NULL, save_temp = NULL)
}
\arguments{
\item{y}{List of observations in matrix form. NAs allowed}

\item{t}{List of corresponding time points. NAs not allowed}

\item{basis_fct}{Basis function for spline}

\item{warp_fct}{Warp function}

\item{amp_cov}{Amplitude covariance function. Must be on the form \code{function(t, param)}}

\item{warp_cov}{Warp covariance function. Must be on the form \code{function(t, param)}}

\item{iter}{two-dimensional integer of maximal number of outer iterations &
maximal number of inner iterations per outer iteration.}

\item{w0}{Starting values for predicted warps. Should only be used if you have results from a previous run.}

\item{amp_cov_par}{Starting values for amplitude covariance parameters. There are no defaults.}

\item{use.nlm}{Use \code{nlm} instead of \code{optim} for optimization? First index for outer loop, second index for inner loop.}

\item{paramMax}{Logical vector. Which amplitude parameters to optimise over? Defaults to all parameters.
May be overwritten by supplying control parameters.}

\item{parallel}{Which parts be run in parallel? Character vector. Possibilities are
\code{c("warp prediction", "likelihood", "amplitude covariance", "spline weights")}. Partial matching allowed. See details.}

\item{warp_opt}{If \code{FALSE}, warp covariance parameters are kept fixed.}

\item{like_optim_control}{List of control options for optimization in outer loop. See details}

\item{pr}{Printing option.}

\item{design}{Design for the experiments. Should be given as a list of one-dimensional vectors or as a design matrix.}

\item{save_temp}{Save estimates after each outer iteration? \code{NULL} or the file path.}

\item{use_laplace}{Use Laplace approximation? (as opposed to linearization)}
}
\value{
A list of estimates
}
\description{
Simultaneous inference for Misaligned Multivarariate functional data
}
\details{
ppMulti returns a warning if applied on one-dimensional functional data.

Control parameters:

\code{lower}, \code{upper}, method, ndeps, \code{maxit} will be sent to optim/nlm. The first indices in lower/upper are warp parameter bounds.
#' See \link{optim} for more details.

If \code{use.nlm} is selected the optimization is performed using the \code{nlm} function.
Bounds are handled through transformation. Note that the optimization will not be able to actually reach the bounds.

The first entries of lower/upper correspond to warp parameters, while the rest corresponds to
amplitude parameters. ppMulti does match upper/lower with corresponding entries in amp_cov, which is important when not all parameters are maximized over.
This is for consistency with randomCycle and optimRule.

randomCycle and optimRule are two ways of optimizing on only a subset of the parameters at a time. These overwrites the paramMax argument.
TBD: descriptions of these.

Amplitude covariance uses all time points from first observation coordinate, all time points from second observation coordinate etc.

Parallel arguments:

\code{warp prediction} runs the inner loop of warp prediction in parallel. \code{likelihood} calculates the likelihood in parallel.
\code{amplitude covariance} updates (inverse) covariances in parallel (outside of outer loop). \code{spline weights} runs estimation of spline weights in parallel.
Note that \code{simm.fda} just calls \code{foreach} and does not provide any tools for handling parallelization objects (this is a deliberate design strategy).
}
\examples{
\link{example}

\donttest{
# Data originates from http://mocap.cs.cmu.edu/

## Data is provided as
# MCD.data y-values
# MCD.time time points

# Make basis function
bf <- make_basis_fct(seq(0, 1, len=32)[2:31], intercept=T, boundary = c(0, 1))

## Make warp function
tw <- seq(0, 1, length = 5)[2:4] ## anchor points for hyman spline
wf.noshift <- make_warp_fct(type="smooth", tw=tw)

## warp function with shift
wf <- w.shift(wf.noshift, 0.25)

warp_cov <- warp_and_shift_cov(c(0.5, 1))


## For this example we assume no amplitude cross-correlation, otherwise ...
# Matern covariance; smoothness parameter 2, unknown range.

wrapper <- function(t, par) {
  mvMatern(t, par[1], 2, rep(1,3), diag(par[2:4]))
}

lower <- c(1e-4, 1e-4,rep(1e-4, 4))
upper <- rep(1e5, 6)

# Note this will take a long time:
mcd.res <-ppMulti(MCD.data, MCD.time, bf, wf, amp_cov = wrapper, warp_cov, amp_cov_par = c(0.2, rep(100, 3)), pr = F, paramMax = rep(T, 4),
                  like_optim_control = list(lower = lower, upper = upper), win = F, iter = c(10, 10))
}

}
\seealso{
Important details can be found in simm-fda-short-desc.pdf
}
