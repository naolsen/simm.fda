% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pp-multi_2.R
\name{ppMulti}
\alias{ppMulti}
\title{Simultaneous inference for Misaligned Multivarariate functional data}
\usage{
ppMulti(y, t, basis_fct, warp_fct, amp_cov = NULL, warp_cov = NULL,
  iter = c(5, 5), w0 = NULL, use.nlm = c(FALSE, FALSE),
  functional = NULL, amp_cov_par = NULL, paramMax = rep(TRUE,
  length(amp_cov_par)), like.alt = FALSE, warp_opt = TRUE,
  like_optim_control = list(), pr = FALSE, design = NULL,
  inner_parallel = FALSE, save_temp = NULL)
}
\arguments{
\item{y}{List of observations in matrix form. NAs allowed}

\item{t}{List of corresponding time points. NAs not allowed}

\item{basis_fct}{Basis function for spline}

\item{warp_fct}{Warp function}

\item{amp_cov}{Amplitude covariance. Must be on the form function(t, param)}

\item{warp_cov}{Warp covariance}

\item{iter}{two-dimensional integer of maximal number of outer iterations &
maximal number of inner iterations per outer iteration.}

\item{w0}{Starting values for warp. Should only be used if you have results frmo a previous run.}

\item{use.nlm}{Use \code{nlm} instead of \code{optim} for optimization? First index for outer loop, second index for inner loop.}

\item{amp_cov_par}{Starting values for amplitude covariance parameters. There are no defaults.}

\item{paramMax}{Logical vector. Which amplitude parameters to optimise over? Defaults to all parameters.
May be overwritten by supplying control parameters.}

\item{like.alt}{Do not change}

\item{warp_opt}{If FALSE, warp covariance parameters are kept fixed.}

\item{like_optim_control}{List of control options for optimization in outer loop. See details}

\item{pr}{Printing option.}

\item{design}{Design for the experiments. Should be given as a list of one-dimensional vectors or as a design matrix.}

\item{inner_parallel}{Should the inner optimization be done parallelly?}

\item{save_temp}{Save estimates after each outer iteration? NULL or the file path.}

\item{functional:}{Optional and experimnetal parameter that allows the user to use the experimental Functionality package. 
Value should be a functional call with one optional argument(ownDeriv = ) that initializes the functional object.
If ownDeriv = TRUE the native derivative of the functional object is used, otherwise finite differences are used.}
}
\value{
A list of estimates
}
\description{
Simultaneous inference for Misaligned Multivarariate functional data
}
\details{
ppMulti returns a warning if applied on one-dimensional functional data.

Control parameters:


lower, upper, method, ndeps, maxit will be sent to optim. See optim for more details. 
If use.nlm is selected the optimization is performed using the nlm function. 
Bounds are handled through a logit transformation. Note that the optimization will not be able to actually reach the bounds.
Presently, the user cannot pass any control values to nlm.

The first entries of lower/upper correspond to warp parameters, while the rest corresponds to
amplitude parameters. ppMulti does match upper/lower with corresponding entries in amp_cov, which is important when not all parameters are maximized over. 
This is for consistency with randomCycle and optimRule.

randomCycle and optimRule are two ways of optimizing on only a subset of the parameters at a time. These overwrites the paramMax argument.
TBD: descriptions of these.

Regarding parallelization: The user must initiate and control parallelization objects by herself. 
simm.fda just calls \code{foreach} and does not provide any tools for handling parallelization objects (this is a deliberate design strategy).
Note that parallelization does not work in every situation and may depend on operative system among other things.
}
\examples{
\\link{example}

\donttest{
# Data originates from http://mocap.cs.cmu.edu/

## Data is provided as
# MCD.data y-values
# MCD.time time points

# Make basis function
bf <- make_basis_fct(seq(0, 1, len=32)[2:31], intercept=T, boundary = c(0, 1))

## Make warp function
tw <- seq(0, 1, length = 5)[2:4] ## anchor points for hyman spline
wf.noshift <- make_warp_fct(type="smooth", tw=tw)

## warp function with shift
wf <- w.shift(wf.noshift, 0.25)

warp_cov <- warp_and_shift_cov(c(0.5, 1))


## For this example we assume no amplitude cross-correlation, otherwise ...
# Matern covariance; smoothness parameter 2, unknown range.

wrapper <- function(t, par) {
  mvMatern(t, par[1], 2, rep(1,3), diag(par[2:4]))
}

lower <- c(1e-4, 1e-4,rep(1e-4, 4))
upper <- rep(1e5, 6)

# Note this will take a long time:
mcd.res <-ppMulti(MCD.data, MCD.time, bf, wf, amp_cov = wrapper, warp_cov, amp_cov_par = c(0.2, rep(100, 3)), pr = F, paramMax = rep(T, 4),
                  like_optim_control = list(lower = lower, upper = upper), win = F, iter = c(10, 10))
}

}
\seealso{
Important details can be found in simm-fda-short-desc.pdf
}

